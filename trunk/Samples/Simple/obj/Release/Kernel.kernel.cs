//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Kernel {
    using System.IO;
    using OpenCL.Net;
    using OpenCL.Net.Extensions;
    
    
    public class doSomething : OpenCL.Net.Extensions.KernelWrapperBase {
        
        public doSomething(OpenCL.Net.Context context) : 
                base(context) {
        }
        
        protected internal override string KernelPath {
            get {
                return System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "Kernel.cl");
            }
        }
        
        protected internal override string OriginalKernelPath {
            get {
                return "C:\\Users\\splitice\\Documents\\GitHub\\OpenCL.Net\\trunk\\Samples\\Simple\\Kernel.cl";
            }
        }
        
        protected internal override string KernelSource {
            get {
                return System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "Kernel.cl");
            }
        }
        
        protected internal override string KernelName {
            get {
                return "doSomething";
            }
        }
        
        private OpenCL.Net.Event run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem<System.Single> a, OpenCL.Net.IMem<System.Single> b, int local_length, float scale, uint globalWorkSize0, uint globalWorkSize1 = 0, uint globalWorkSize2 = 0, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 0, a);
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 1, b);
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 2, ((System.IntPtr)((local_length * OpenCL.Net.TypeSize<uchar3>.SizeInt))), null);
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 3, scale);
            OpenCL.Net.Event ev;
            OpenCL.Net.ErrorCode err;
            err = OpenCL.Net.Cl.EnqueueNDRangeKernel(commandQueue, this.Kernel, base.GetWorkDimension(globalWorkSize0, globalWorkSize1, globalWorkSize2), null, base.GetWorkSizes(globalWorkSize0, globalWorkSize1, globalWorkSize2), base.GetWorkSizes(localWorkSize0, localWorkSize1, localWorkSize2), ((uint)(waitFor.Length)), waitFor.Length == 0 ? null : waitFor, out ev);
            OpenCL.Net.Cl.Check(err);
            return ev;
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem<System.Single> a, OpenCL.Net.IMem<System.Single> b, int local_length, float scale, uint globalWorkSize, uint localWorkSize = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, a, b, local_length, scale, globalWorkSize0: globalWorkSize, localWorkSize0: localWorkSize, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem<System.Single> a, OpenCL.Net.IMem<System.Single> b, int local_length, float scale, uint globalWorkSize, uint localWorkSize = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, a, b, local_length, scale, globalWorkSize0: globalWorkSize, localWorkSize0: localWorkSize, waitFor: waitFor);
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem<System.Single> a, OpenCL.Net.IMem<System.Single> b, int local_length, float scale, uint globalWorkSize0, uint globalWorkSize1, uint localWorkSize0 = 0, uint localWorkSize1 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, a, b, local_length, scale, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem<System.Single> a, OpenCL.Net.IMem<System.Single> b, int local_length, float scale, uint globalWorkSize0, uint globalWorkSize1, uint localWorkSize0 = 0, uint localWorkSize1 = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, a, b, local_length, scale, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, waitFor: waitFor);
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem<System.Single> a, OpenCL.Net.IMem<System.Single> b, int local_length, float scale, uint globalWorkSize0, uint globalWorkSize1, uint globalWorkSize2, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, a, b, local_length, scale, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, globalWorkSize2: globalWorkSize2, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, localWorkSize2: localWorkSize2, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem<System.Single> a, OpenCL.Net.IMem<System.Single> b, int local_length, float scale, uint globalWorkSize0, uint globalWorkSize1, uint globalWorkSize2, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, a, b, local_length, scale, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, globalWorkSize2: globalWorkSize2, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, localWorkSize2: localWorkSize2, waitFor: waitFor);
        }
    }
}
